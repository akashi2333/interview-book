# HTML、HTTP、HTTPS、浏览器相关

## H5新特性

- 新增语义化标签（标签有自己的含义，页面内容结构化、便于阅读理解维护）：`<footer>`、`<article>`、`<nav>`、`<section>`、`<header>`等。
- 用于绘画的`<canvas>`标签。
- 用于媒体回放的`<video>`和`<audio>`标签。
- 存储：提供了`sessionStorage`和`localStorage`。
- 新增input类型：`color`、`url`、`email`、`date`等。
- 新增表单控件：`placeholder`（文本默认提示文字）、`autofocus`（自动获取焦点）、`autocomlpete`（联想关键词）等。

## 元素类型

### 行内元素`display:inline;`。

#### 特点

- 排在一行内，不会自动换行。
- 宽高无效。
- `padding`对于水平方向正常有效，垂直方向只有效果，对其他元素无任何影响。

- `margin`对于水平方向有效，垂直方向无效。

#### 常见的行内元素

`<a>`、`<span>`、`<i>`、`<strong>`、`<img>`、`<input>`、`<button>`等。

### 块级元素`display:block;`。

#### 特点

- 独占一行，自动换行。
- 可以指定宽高。
- `margin`和`padding`在四个方向上都有效。

#### 常见的块级元素

`<div>`、`<aside>`、`<nav>`、`<form>`、`<ul>`、`<li>`等

### 行内块级元素`display:inline-block;`。

#### 特点

- 可以指定宽高。
- `margin`和`padding`在四个方向上都有效。
- 元素排在一行，但是会有空白间隙。

#### 常见的行内块级元素

`<button>`、`<img>`、`<input>`、`<select>`、`<textarea>`、`<iframe>`。

## Canvas相关

只是一个二维网格的图形容器，绘制图形要用`js`来定位绘制。

比如画一条线，要先找到`canvas`元素，创建`context`对象，用`moveTo`和`lineTo`定位，再用`stroke`绘制。

```
var c=document.getElementById("myCanvas"); 
var ctx=c.getContext("2d"); 
ctx.moveTo(0,0); 
ctx.lineTo(200,100); 
ctx.stroke();
```

再比如画圆，也要先找到`canvas`元素，创建`context`对象，用`beginPath`开始路径，用`arc`确定圆的位置和大小，然后`closePath`关闭路径，最后再用`stroke`或`fill`绘制。

```
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
ctx.beginPath();
ctx.arc(95,50,40,0,2*Math.PI);
ctx.closePath();
ctx.stroke();
```

## HTTP与HTTPS的区别

`http`是超文本传输协议，而`https`相当于安全版的`http`。

具体区别：

- `http`是明文传输，而`https`是有着`ssl`加密传输协议的。
- `http`的端口是80，而`https`的端口是443。
- `https`需要`ssl`证书，费用比较昂贵,而`http`不需要。

## HTTP1.0、HTTP1.1、HTTP2.0的特点

### HTTP1.0的特点

- 协议版本信息会随着每个请求发送，即`HTTP 1.0`被追加到了`GET`行。
- 引入请求头，在发起请求时候会通过`HTTP`请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。
- 引入响应头，服务器以请求头中信息准备数据，并以响应头的信息告诉客户端数据采用何种格式返回，倘若遇到不支持的格式，只能返回服务器支持的格式，并在响应头中体现，也就是说最终浏览器是以响应头的信息解析数据。
- 引入状态码，状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为。
- 引入了缓存机制，通过状态码与`If-Modified-Since`、`Expires`等控制更新或使用本地缓存。
- 引入了`Content-Type`头，使`HTTP`具备了传输除纯文本`HTML`文件以外其他类型文档的能力。

### HTTP1.1的特点

- 缓存处理，`HTTP 1.1`引入了更多的缓存控制策略，例如`Entity tag`、`If-Unmodified-Since`、`If-Match`、`If-None-Match`等更多可供选择的缓存头来控制缓存策略。
- 带宽优化以及网络连接的使用，在请求头中引入了`range`，它允许只请求资源的某一个部分，即返回`206`状态码，这样方便了开发者自由选择以便充分利用带宽和链接，并且可以使用`Range`和`Content-Range`制作断点续传功能。
- 错误通知的管理，在`HTTP 1.1`中新增了`24`个错误状态码。
- 增加`Host`请求头，能够使不同域名配置在同一个`IP`地址的服务器上。
- 支持长连接，`HTTP 1.1`支持长连接，在一个`TCP`连接上可以传输多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟，在`HTTP 1.1`中默认开启`Connection：keep-alive`，一般浏览器对于同一个域名允许同时建立`6`个长链接。
- 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以改善队头阻塞问题，但响应的顺序还是会按照请求的顺序返回。
- 支持响应分块，通过设置`Transfer-Encoding: chunked`进行分块响应，允许响应的数据可以分成多个部分，配合服务端尽早释放缓冲可以获得更快的响应速度。

### HTTP2.0的特点

- 二进制分帧，`HTTP 2.0`是二进制协议而不是文本协议，将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码。
- 多路复用，并行的请求能在同一个链接中处理，在同一域名下所有访问都是从同一个`TCP`连接中走，`HTTP`消息被分解为独立的帧，服务端根据标识符和首部将消息重新组装起来，移除了`HTTP 1.1`中顺序和阻塞的约束。
- 压缩`header`，`header`在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
- 服务端推送，服务器可以主动地向客户端推送资源，而无需客户端明确的请求。

## HTTP请求方法

| 请求方法 |                           方法含义                           |
| :------: | :----------------------------------------------------------: |
|   get    |                   请求页面信息返回响应主体                   |
|   post   |                           提交数据                           |
|   head   |             获取响应头信息，常用于查看客户端性能             |
| options  | 请求服务器返回该资源所支持的所有请求方法，常用于客户端查看服务器的性能 |
|  trace   |  请求服务器回显其收到的请求信息，常用于HTTP请求的测试或诊断  |
|   put    |                   指定资源位置上传最新内容                   |
|  delete  |                   删除所请求URI标识的资源                    |
| connect  | 将连接改为管道方式的代理服务器，常用于SSL加密服务器与非加密的HTTP代理服务器的通信 |

## Get和Post的区别

- get参数放在URL中传递、post参数放在request body中传递。
- get只能进行URL编码，而post可以用多种方式编码。
- get能够使用缓存，post不行。
- get传递参数有长度限制，post没有。
- get产生一个TCP包，而post产生两个TCP包（get把header和data一并发送，而post先发送header，响应100后再继续发送data）。
- get参数会被保留在历史记录里，而post不会。
- get浏览器回退无害，post会再次请求。
- get满足幂等性，post不满足。（幂等性：一次请求和多次请求某一资源具有同样的副作用，put、delete都满足）

## HTTP状态码

1XX代表通知，2XX代表操作成功，3XX代表重定向，4XX代表客户端错误，5XX代表服务端错误。

| 状态码 |                         含义                         |
| :----: | :--------------------------------------------------: |
|  200   |                    客户端请求成功                    |
|  301   | 永久移动，资源移动到新的URI中，之后用新的URI请求资源 |
|  302   |    暂时移动，资源临时移动，可以用旧的URI请求资源     |
|  304   |      未修改，请求的资源没有改动，不返回任何资源      |
|  400   |                  客户端请求语法错误                  |
|  401   |                     需要用户验证                     |
|  404   |                    请求资源不存在                    |
|  500   |                    服务器发生错误                    |

## HTTP头部

### 请求消息Request

请求消息一般包括请求行、请求头部、空行和请求数据四个部分。

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

### 响应消息Response

响应消息一般包括状态行、消息包头、空行和响应正文四个部分。

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

## 输入URL后发生了什么

1. 寻找服务器`ip`，现在缓存中找，然后在本地`hosts`文件里找，最后查询`DNS`服务器。
2. 建立`TCP`连接，发送`http`请求，依次经过传输层、网络层、数据链路层和物理层到达服务器，服务器解析请求返还相应的`html`，关闭`TCP`连接。
3. 浏览器根据返回的`html`构建`DOM`树，中途如果遇到图片、视频等资源会并行下载，如果遇到`js`脚本，会先下载相应的`js`脚本，这会造成阻塞，然后根据样式构建`CSSOM`树，接着两棵树合成`render`树。
4. 最后进行布局绘制。

*`window.onload`在页面载入完成时执行，`DOMContentLoaded`在`DOM`树构建完成时执行。

## HTTPS加密方式

### 加密过程

1. 浏览器通过`url`向服务器发送请求，要求建立`SSL`连接。
2. 服务器接受请求后返回公钥证书。
3. 浏览器验证公钥证书是否有效，如果有效就生成会话密钥，并用公钥加密会话密钥发送给服务器。
4. 服务器通过自己的私钥解密会话密钥。此时两方都有了相同的会话密钥。
5. 服务器与浏览器通过会话密钥加密双方的通信。

### 对称加密与非对称加密

对称加密：加密和解密使用同一个密钥。

非对称加密：发送端使用公钥加密，接收端使用私钥解密。

- RSA算法：两个大素数的乘积作为公钥，两个大素数作为私钥。（乘积因式分解困难）

HTTPS使用非对称加密传输对称密钥，使用对称密钥传输数据。

## HTTP缓存（浏览器缓存）

- 强缓存：直接从本地缓存读取资源，返回状态码200。

- 协商缓存：向服务器发送请求，由服务器通知缓存是否可以使用，返回状态码304。

浏览器首先查看头部信息，如果`cache-control`值为`no-cache`或者资源时间（`max-age`）失效会命中协商缓存，这时会发送一个请求到服务器，服务器比较`if-None-Match`和之前的`Etag`值是否相等，如果没有`Etag`值就再比较`if-Modify-Since`和`Last-Modify`值是否相等，如果相等那返回304，否则返回最新的资源。

![img](https://barryyeee.github.io/InterviewGuide/Images/HTTP%E7%BC%93%E5%AD%98.jpg)

## 会话跟踪

### Cookie

`cookie`是服务器发送到浏览器并保存在本地的一小块数据，对于同源的每个请求都会自动携带`cookie`，于是服务端就可以判断用户身份。

### Session

`session`代表着服务器与客户端一次会话的过程。对于客户端的每个会话，都有一个唯一的`SESSIONID`与其对应，服务端将用户数据存储进`SESSIONID`对应的文件或者是内存中，只要客户端每次请求将`SESSIONID`交予服务端，服务端就能区别用户进行会话跟踪。

### Cookie和Session的区别

- cookie保存在客户端，session保存在服务器端。
- cookie只能保存ASCII码，session可以保存任意数据类型。
- cookie相较于session不安全。
- cookie只有4K左右大小，session可存取数据远高于cookie。
- cookie可以长时间保存，session一般客户端关闭或者session超时都会失效。

### Cookie和Session的配合

用户第一次请求服务器时，服务器会根据用户提交的信息创建对应的`session`，然后会把`SESSIONID`返回给浏览器，浏览器将`SESSIONID`存入`cookie`，同时记录`SESSIONID`的域名。

当用户再次请求服务器时，请求会自动判断当前域名是否存在`cookie`，如果存在就将`cookie`一起发送给服务器，服务器会从中获取`SESSIONID`，再通过`SESSIONID`查找相应的`session`，如果没有找到就说明用户没有登陆或者登录失效，如果找到就执行之后的操作。

### 浏览器禁用Cookie

- 每个请求都带有`SESSIONID`参数信息。
- `Token`机制：当用户第一次登录后，服务器根据提交的用户信息生成一个 `Token`，响应时将 `Token` 返回给客户端，以后客户端只需带上这个 `Token` 前来请求数据即可，无需再次登录验证。

### 分布式Session（共享Session）

将session存在数据库里，保障分发到每一个服务器的响应结果都一致。

## 浏览器存储

### Cookie

属于DOM树根节点document，在请求头上带着数据，大小限制4K。

- expires：过期时间。
- path：路径，相同路径的页面可以共享cookie。
- domain：主机名。

### Session Storage

BOM对象window，以键值对的形式存在，存储类型是String类型，存储大小大约为5M。在用户关闭浏览器后数据就会失效。

### Local Storage

BOM对象window，以键值对的形式存在，存储类型是String类型，存储大小大约为5M。永久存在，除非手动删除。

### Cookie、Local Storage和Session Storage的区别

- `cookie`只有4k左右的大小，而`sessionStorage`和`localStorage`有5MB的大小。

- `cookie`在时间过期前都有效，`sessionStorage`窗口关闭之前有效，而`localStorage`永久有效。

- `cookie`和`localSorage`可以同源窗口共享，而`sessionStorage`不行。

- `cookie`在浏览器和服务器之间来回传递，`localStorage`和`sessionStorage`仅在本地保存。

## XSS攻击

页面被注入恶意脚本，使之在用户浏览器上运行，利用这些脚本获取用户敏感信息从而危害数据安全。

分类：

- 存储型：恶意代码存在数据库中，用户打开网站时，服务器取出恶意代码，拼接在html中返回给浏览器，然后解析执行。
- 反射型：构造包含恶意代码的URL，用户打开URL后，服务器将恶意代码取出，拼接在html中返回给浏览器，然后解析执行。
- DOM型：构造包含恶意代码的URL，用户打开URL后，浏览器收到响应后，前端`js`取出恶意代码解析执行。

防御：cookie设置`httponly`和secure；进行特殊字符过滤；对用户的输入进行检查。

## CSRF攻击

可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求。

![image-20210526225556711](C:\Users\akash\AppData\Roaming\Typora\typora-user-images\image-20210526225556711.png)

防御：使用验证码、使用token。

## 跨域

原因：浏览器同源策略：非同源的不能够交互。

解决方案：

- CORS
  - 简单请求：请求中有`origin`头部，其中包含请求页面的源信息，服务器根据这个头部信息来决定是否响应，如果服务器认为这个请求可以接受就在`Access-Control-Allow-Origin`头部中会发相同的源信息，如果源信息不匹配就驳回请求。
  - 非简单请求：发送真正的请求前会发送一个`Preflight`请求给服务器，该请求使用OPTIONS方法，发送`Origin`、`Access-Control-Request-Method`头部，然后服务器决定是否允许这种类型的请求，通过在响应中发送头部与浏览器沟通，一旦服务器通过`Preflight`请求允许该请求后，浏览器就可以正常的CORS请求了。

- JSONP
  - `js`不受浏览器同源策略的影响，可以通过`script`标签进行跨域请求。
  - 只支持`Get`请求。

- 服务端代理：有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。

## 前端性能优化

1. 降低请求量：合并CSS、JS和图片（精灵图）。
2. 使用缓存：http缓存（浏览器缓存）。
3. 加快请求速度：预解析DNS、CDN分发（本质缓存）。
4. 将CSS样式表放在顶部（CSS全部下载完才对页面进行渲染），JS脚本放在底部（加载JS后立即执行可能会阻塞整个页面）。
5. 图片懒加载：访问页面时先把图片替换成一张占位图，当图片出现在浏览器可视区域时（如果图片顶部到页面顶部的距离<=可视区域高度+滚动区域高度的和时代表进入可视区域），才显示真正的图片内容。
6. 减少cookie的传输（太大会严重影响数据传输，避免请求静态资源时发送cookie）。

## 重排重绘

- 重排：部分或整个渲染树需要重新分析并且节点尺寸需要重新计算，比如浏览器窗口大小改变、元素尺寸或位置改变。

- 重绘：由于节点的样式发生改变比如字体颜色改变，屏幕上的部分内容需要更新。

## CDN

内容分发网络，能够通过DNS查找离用户最近的CDN节点的IP，然后通过IP访问实际资源，如果CDN上没有缓存资源，就会到源站请求资源并缓存到CDN，这样用户下一次访问，就直接用CDN缓存的资源了。

## DNS

域名系统、将域名和IP地址相互映射的一个分布式数据库。

- 主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的IP地址时，本地域名服务器就以DNS客户的身份向其他根域名服务器继续发送查询请求报文，而不是让该主机自己进行下一步的查询。

- 本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询，然后让本地域名服务器进行后续的查询。逐步按照域树的路径向下走直到叶节点，得到了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。当然本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文的设置是要使用哪一种查询方式。

## TCP相关

- TCP是面向连接的协议，提供全双工通信。
- TCP使用校验、确认和重传机制来保证可靠传输。
- TCP首部最小有20字节。
- TCP只能是一对一通信。
- TCP面向字节流通信。
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。

### 三次握手

1. 第一次握手：建立连接。客户端发送连接请求报文段，将`SYN`位置为1，`seq`随机的为x；然后，客户端进入`SYN_SEND`状态，等待服务器端的确认。服务器端由`SYN=1`知道，客户端请求建立连接；
2. 第二次握手：服务器端收到`SYN`报文段，需要确认联机信息，设置`ack`为x+1(客户端的`seq+1`)；同时，自己还要发送`SYN`请求信息，将`SYN`位置为1，`seq`再随机为y；此时服务器进入`SYN_RECV`状态；
3. 第三次握手：客户端收到后检查`ack`是否正确。即第一次发送的`seq+1`,以及位码`ack`是否为1，若正确，客户端会再发送`ack`=(服务器的`seq`+1),`ack=1`，服务器收到后确认`seq`值与`ack=1`，则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png)

### 四次挥手

1. 第一次挥手：客户端发送一个`FIN`，用来关闭客户端到服务器端的数据传送，客户端进入`FIN_WAIT_1`状态。
2. 第二次挥手：服务器端收到`FIN`后，发送一个`ACK`给客户端，确认序号为收到序号+1（与`SYN`相同，一个`FIN`占用一个序号），服务器端进入`CLOSE_WAIT`状态。
3. 第三次挥手：服务器端发送一个`FIN`，用来关闭服务器端到客户端的数据传送，服务器端进入`LAST_ACK`状态。
4. 第四次挥手：客户端收到`FIN`后，客户端进入`TIME_WAIT`状态，接着发送一个`ACK`给服务器端，确认序号为收到序号+1，服务器端进入`CLOSED`状态，完成四次挥手。

![四次挥手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png)

### TCP滑动窗口

解决发送方和接收方收发数据速率不一致的问题。滑动窗口相当于接收方的缓存，接收方向发送方通知自己可接受数据的大小，而发送方会根据这个数值发送数据。

发送窗口

- 已经发送并且对端确认（Sent/ACKed）---------------发送窗外 缓冲区外
- 已经发送但未收到确认数据（Sent/UnACKed）----- --发送窗内 缓冲区内
- 允许发送但尚未防的数据（Unsent/Inside）-----------发送窗内 缓冲区内
- 未发送暂不允许（Unsent/Outside）-------------------发送窗外 缓冲区内

接收窗口

“已接收”，“未接收准备接收”，“未接收并未准备接收”。其中“未接收准备接收”称之为接收窗口。

### 与UDP的区别

- UDP无连接，不可靠。
- UDP面向报文。
- UDP可以一对一或者一对多。
- UDP首部只有8字节。
- UDP用于高速传输和对实时性有较高要求的通信（视频、音频等多媒体通信）或广播通信。