<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div class="box">
    <div class="content">content</div>
  </div>
</body>

</html>

<style>
  .box {
    position: relative;
    width: 100px;
    height: 100px;
    background-color: green;
  }

  .content {
    position: absolute;
    margin: auto;
    top: 50%;
    left: 50%;
    width: 50px;
    height: 50px;
    margin-top: -25px;
    margin-left: -25px;
    background-color: red;
  }
</style>

<script>
  //实现bind函数
  Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () { };

    var fBound = function () {
      var bindArgs = Array.prototype.slice.call(arguments);
      return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
  }

  //实现instanceof：两种方法
  function myInstanceOf(target1, target2) {
    // let proto = Object.getPrototypeOf(target1);
    // if (proto === target2.prototype) {
    //   return true;
    // } else if (!proto) {
    //   return false;
    // } else {
    //   return myInstanceOf(proto, target2)
    // }
    return target2.prototype.isPrototypeOf(target1);
  }

  //实现map
  function MyMap(arr, callback) {
    var res = [];
    for (var i = 0; i < arr.length; i++) {
      res.push(callback(arr[i], i, arr));
    }
    return res;
  }

  //实现reduce
  function MyReduce(arr, callback, initVal) {
    var result = initVal ? initVal : arr[0];
    for (var i = initVal ? 0 : 1; i < arr.length; i++) {
      result = callback(result, arr[i], i, arr);
    }
    return result;
  }

  //实现filter
  function MyFilter(arr, callback) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
      if (callback(arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }

  //数组去重
  var arr = [1, 2, 3, 1, 1];
  // var arr1 = Array.from(new Set(arr));

  function unique(array) {
    return array.reduce((pre, cur) => pre.includes(cur) ? pre : [...pre, cur], []);
  }
  var arr1 = unique(arr);
  console.log(arr1);



  //数组展平
  var arr2 = [1, 2, [1, 3, 4, [6, 7, 5]], 5];
  // var arr3 = arr2.flat(Infinity);

  function flatten(array) {
    return array.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? flatten(cur) : cur), [])
  }
  var arr3 = flatten(arr2);
  console.log(arr3);

  //浅拷贝：拷贝基本数据类型的值，拷贝引用类型的地址
  function shollowClone(obj) {
    var newobj = {};
    for (let prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        newobj[prop] = obj[prop];
      }
    }
    return newobj;
  }

  //深拷贝：对象属性完全相同但是地址不同，修改一个，另一个不会改变
  function deepClone(obj) {
    // var _obj = JSON.stringify(obj);
    // var newobj = JSON.parse(_obj);
    var newobj = Array.isArray(obj) ? [] : {};
    if (obj && typeof obj === 'object') {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (obj[key] && typeof obj[key] === 'object') {
            newobj[key] = deepClone(obj[key]);
          } else {
            newobj[key] = obj[key]
          }
        }
      }
    }
    return newobj;
  }

  //promise实现,A+规则
  function mypromise(constructor) {
    self = this;
    self.value;
    self.err;
    self.status = 'pending';
    function reslove(value) {
      if (self.status === 'pending') {
        self.status = 'resolved';
        self.value = value;
      }
    }
    function reject(err) {
      if (self.status === 'pending') {
        self.status = 'rejected';
        self.err = err;
      }
    }
    try {
      constructor(reslove, reject);
    }
    catch (e) {
      reject(e);
    }
  }
  mypromise.prototype.then = function (onFullfilled, onRejected) {
    let self = this;
    switch (self.status) {
      case "resolved":
        onFullfilled(self.value);
        break;
      case "rejected":
        onRejected(self.err);
        break;
      default:
    }
  }

  //promise.all实现
  function promiseAll(list) {
    var finishedVal = new Array(list.length);
    var count = 0;
    return new Promise((resolve, reject) => {
      for (var i = 0; i < list.length; i++) {
        //不是promise对象,就用promise.resolve转成promise对象
        Promise.resolve(list[i].then((val) => {
          finishedVal[i] = val;
          count++;
          if (count === list.length) {
            return resolve(finishedVal);
          }
        }, function (err) {
          return reject(err);
        }))
      }
    })
  }

  //promise.race实现
  function promiseRace(list) {
    return new Promise((resolve, reject) => {
      for (var i = 0; i < list.length; i++) {
        Promise.resolve(list[i].then((val) => {
          return resolve(val);
        }, function (err) {
          return reject(err);
        }))
      }
    })
  }

  //防抖函数：触发n秒后执行，如果n秒之内又触发就重新计时
  function debounce(fn, delay) {
    var timer;
    return function () {
      var self = this;
      var args = arguments;
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(function () {
        fn.apply(self, args);
      }, delay);
    };
  }

  //节流函数：不会立即执行，每隔一段时间，只执行一次
  function throttle(fn, delay) {
    var timer;
    return function () {
      var self = this;
      var args = arguments;
      if (timer) {
        return;
      }
      timer = setTimeout(function () {
        fn.apply(self, args);
        timer = null;
      }, delay);
    };
  }

  //AJAX实现:创建对象、设置请求函数和回调函数、获取异步对象的readyState属性、判断响应报文的状态、读取响应数据
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open("GET", "/try/ajax/demo_get.php", true);
  xmlhttp.send();
  xmlhttp.onreadystatechange = function () {
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
      document.getElementById("mydiv").innerHTML = xmlhttp.responseText;
    }
  }

  function promiseAjax() {
    return new Promise((resolve, reject) => {
      var xmlhttp = new XMLHttpRequest();
      xmlhttp.open("GET", "/try/ajax/demo_get.php", true);
      xmlhttp.send();
      xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
          resolve(JSON.parse(xmlhttp.responseText));
        } else {
          reject(JSON.parse(xmlhttp.responseText));
        }
      }
    })
  }

  //冒泡排序:O(n^2)
  function bubbleSort(array) {
    for (let i = 0; i < array.length - 1; i++) {
      for (let j = 0; j < array.length - 1 - i; j++) {
        if (array[j] > array[j + 1]) {
          let temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }

  //选择排序:O(n^2)
  function selectionSort(array) {
    for (let i = 0; i < array.length - 1; i++) {
      let min = i;
      for (let j = i + 1; j < array.length; j++) {
        if (array[j] < array[min]) {
          min = j;
        }
      }
      let temp = array[i];
      array[i] = array[min];
      array[min] = temp;
    }
    return array;
  }

  //插入排序:O(n^2)
  function insertionSort(array) {
    var len = array.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
      preIndex = i - 1;
      current = array[i];
      while (preIndex >= 0 && array[preIndex] > current) {
        array[preIndex + 1] = array[preIndex];
        preIndex--;
      }
      array[preIndex + 1] = current;
    }
    return array;
  }

  //希尔排序:O(nlogn)
  function shellSort(array) {
    for (let gap = Math.floor(array.length / 2); gap > 0; gap = Math.floor(gap / 2)) {
      for (let i = gap; i < array.length; i++) {
        let cur = array[i];
        let j = i;
        while (j - gap >= 0 && cur < array[j - gap]) {
          array[i] = array[i - gap];
          j = j - gap;
        }
        array[j] = cur;
      }
    }
    return array;
  }

  //归并排序:分治 O(nlogn)
  function mergeSort(array) {
    if (array.length <= 1) {
      return array;
    }
    var mid = Math.floor(array.length / 2);
    var left = array.slice(0, mid);
    var right = array.slice(mid);
    return merge(mergeSort(left), mergeSort(right));
  }
  function merge(left, right) {
    var result = [];
    while (left.length && right.length) {
      if (left[0] < right[0]) {
        result.push(left.shift());
      }
      if (left[0] > right[0]) {
        result.push(right.shift());
      }
    }
    return result.concat(left, right);
  }


  //二分查找(递归)
  function binarySearch1(array, left, right, key) {
    if (left > right) {
      return -1;
    }
    var mid = parseInt((left + right) / 2);
    if (key < array[mid]) {
      right = mid - 1;
      return binarySearch(array, left, right, key);
    } else if (key > array[mid]) {
      left = mid + 1;
      return binarySearch(array, left, right, key);
    } else if (key == array[mid]) {
      return mid;
    }
  }
  //二分查找（非递归）
  function binarySearch2(array, left, right, key) {
    while (left <= right) {
      var mid = parseInt((left + right) / 2);
      if (array[mid] < key) {
        left = mid + 1;
      } else if (array[mid] > key) {
        right = mid - 1;
      } else {
        return mid;
      }
      return -1;
    }
  }
  console.log(binarySearch2(arr5, 0, 6, 7));

  //树的创建
  function createTree(array) {
    var tree = {};
    if (!array.length) {
      tree.value = null;
    } else if (array.length == 1) {
      tree.value = array[0];
    } else {
      tree.value = array[1];
      tree.left = createTree(array[0]);
      tree.right = createTree(array[2]);
    }
    return tree;
  }
  var root = createTree([[[[7], 11, [2]], 4, []], 5, [[13], 8, [[], 4, [1]]]]);
  //中序遍历
  function mid(tree) {
    if (tree.hasOwnProperty("left")) {
      mid(tree.left);
      console.log(tree.value);
      mid(tree.right);
    } else {
      tree.value == null ? console.log("") : console.log(tree.value)
    }
  }
  //前序遍历
  function pre(tree) {
    tree.value == null ? console.log("") : console.log(tree.value);
    if (tree.hasOwnProperty('left')) {
      pre(tree.left);
      pre(tree.right);
    }
  }
  //后序遍历
  function after(tree) {
    if (tree.hasOwnProperty("left")) {
      after(tree.left);
      after(tree.right);
      console.log(tree.value);
    } else {
      tree.value == null ? console.log("") : console.log(tree.value)
    }
  }
  //层序遍历
  function levelOrder(tree) {
    var queue = [];
    queue.push(tree);
    while (queue.length != 0) {
      front = queue.shift();
      if (front.hasOwnProperty("left")) {
        queue.push(front.left);
        queue.push(front.right);
      }
      front.value == null ? console.log("") : console.log(front.value);
    }
  }
  levelOrder(root);

  //dfs算法找二叉树路径之和
  var pathSum = function (root, targetSum) {
    var a = [];
    var dfs = (root, sum, nums) => {
      sum += root.val;
      nums.push(root.val);
      if (root.left) {
        dfs(root.left, sum, nums.slice());
      }
      if (root.right) {
        dfs(root.right, sum, nums.slice());
      }
      if (root.left === null && root.right === null) {
        if (sum === targetSum) {
          a.push(nums);
        }
      }
    }
    return root && dfs(root, 0, []) || a;
  };


  var b = {
    val: 1,
    valueOf: function () {
      return b.val++;
    }
  }
  console.log(b == 1 && b == 2 && b == 3)

</script>